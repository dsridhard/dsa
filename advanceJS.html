<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced JavaScript Concepts</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f9f9f9;
            color: #333;
        }

        h1,
        h2 {
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .concept {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
        }

        ul {
            list-style-type: disc;
            margin-left: 20px;
        }

        strong {
            color: #555;
        }

        pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 4px;
            white-space: pre-wrap;
            word-wrap: break-word;
            border: #333;
            box-shadow: 2px 5px 12px 5px grey;
        }
        pre:hover{
            box-shadow: 1px 2px 6px 2px white;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
        }
        
        .nav-btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: #0056b3;
            color: #eee;
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.3s;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }

        .nav-btn:hover {
            background-color: #004494;
        }
    </style>
</head>

<body>
    <a class="nav-btn" href="./index.html">Main</a>
    <h1>Advanced JavaScript Topics</h1>

    <div class="concept">
        <h2>Closures</h2>
        <p><strong>Brief Details:</strong></p>
        <p>A closure is the combination of a function bundled together (enclosed) with references to its surrounding
            state (the lexical environment). In other words, a closure gives you access to an outer function's scope
            from an inner function. In JavaScript, closures are created every time a function is created, at function
            creation time.</p>
        <p><strong>Example:</strong></p>
        <pre><code class="language-javascript">function outerFunction() {
    let outerVariable = 'I am outside!';
    function innerFunction() {
        console.log(outerVariable); // innerFunction has access to outerVariable
    }
    return innerFunction;
}
const myClosure = outerFunction();
myClosure(); // Logs: 'I am outside!'</code></pre>
        <p><strong>Important Questions:</strong></p>
        <ul style="list-style-type: none;">
            <li>
                <details>
                    <summary>What is a closure? Can you give a practical example?</summary>
                    <p>A closure happens when an inner function “remembers” variables from its outer function’s scope
                        even after the outer function has finished executing.

                        This allows us to hide data from the outside world while still giving controlled access.</p>
                </details>
            </li>
            <li>
                <details>
                    <summary>
                        How do closures help in creating private variables and methods? (The Module Pattern)
                    </summary>
                    <ul>
                        <li>Variables defined inside a function are not accessible from outside that function.
                        </li>
                        <li>If we return an inner function that uses those variables, the inner function keeps a
                            reference to them via a closure.
                        </li>
                        <li>This means we can store data privately and expose only what we want.</li>
                    </ul>
                    <h4>
                        <strong>
                            The Module Pattern:
                        </strong>
                        The Module Pattern uses closures to create private state and public methods.
                    </h4>
                    <pre>
                        <code>
  const CounterModule = (function () {
  // Private variable
  let count = 0;

  // Private method
  function log(message) {
    console.log(`LOG: ${message}`);
  }

  // Public API (returned object)
  return {
    increment() {
      count++;
      log(`Count incremented to ${count}`);
    },
    decrement() {
      count--;
      log(`Count decremented to ${count}`);
    },
    getCount() {
      return count;
    }
  };
})();

// Usage
CounterModule.increment(); // LOG: Count incremented to 1
CounterModule.increment(); // LOG: Count incremented to 2
console.log(CounterModule.getCount()); // 2

// ❌ Direct access to private variables is not possible
console.log(CounterModule.count); // undefined

                        </code>
                    </pre>

                    <h3>
                        <strong>
                            How It Works:
                        </strong>

                    </h3>
                    <ul>
                        <li>IIFE (Immediately Invoked Function Expression) creates a private scope.
                        </li>
                        <li>Variables (count, log) live inside that scope and are not accessible directly from outside.
                        </li>
                        <li>The returned object contains public methods that form closures over the private variables.
                        </li>
                        <li>These public methods can read and modify the private variables, but external code cannot.
                        </li>
                    </ul>
                </details>
            </li>
            <li>
                <details>
                    <summary>
                        What is the relationship between closures and garbage collection?
                    </summary>
                    <p>
                        Closures in JavaScript have a direct relationship with garbage collection because they can
                        extend the lifetime of variables in memory. Normally, when a function finishes executing, all of
                        its local variables are removed from memory during garbage collection since they are no longer
                        accessible. However, if an inner function (a closure) references variables from its outer
                        function, those variables remain in memory as long as the closure itself is still reachable
                        somewhere in the program. This is what allows closures to create private variables, but it also
                        means they can unintentionally cause memory leaks if they capture large objects or DOM elements
                        and are kept alive unnecessarily, such as through global variables or unremoved event listeners.
                        Once there are no more references to the closure, both it and the variables it captured become
                        eligible for garbage collection, freeing up memory.
                    </p>
                </details>
            </li>
            <li>
                <details>

                    <summary>Explain a memory leak scenario related to closures.</summary>
                    <p>
                        A common memory leak scenario with closures happens when a closure unintentionally keeps a large
                        object or DOM element in memory because it’s still referenced somewhere, even though it’s no
                        longer needed.
                    </p>
                    <h3>
                        Example:
                    </h3>
                    <pre>
                        <code>
 function attachHandler(element) {
  // Large object in memory
  let bigData = new Array(1000000).fill('leak');

  // Closure captures 'bigData'
  element.addEventListener('click', function () {
    console.log(bigData.length);
  });
}

// Create a DOM element and attach handler
let button = document.createElement('button');
attachHandler(button);

// Later, remove the element from DOM
document.body.removeChild(button);
// ❌ But we forgot to remove the event listener

                        </code>
                    </pre>
                </details>
            </li>
        </ul>
    </div>

    <div class="concept">
        <h2>'this' Keyword</h2>
        <p><strong>Brief Details:</strong></p>
        <p>The 'this' keyword refers to the object it belongs to. Its value is determined by how a function is called
            (runtime binding).</p>
        <ul>
            <li><strong>Global Context:</strong> In the global scope, 'this' refers to the global object (window in
                browsers).</li>
            <li><strong>Function Context:</strong> In a simple function call, 'this' also refers to the global object
                (or 'undefined' in strict mode).</li>
            <li><strong>Method Context:</strong> When a function is called as a method of an object, 'this' refers to
                the object the method is called on.</li>
            <li><strong>Constructor Context:</strong> In a constructor function (with `new`), 'this' refers to the newly
                created instance.</li>
            <li><strong>Arrow Functions:</strong> Arrow functions do not have their own 'this' context. They inherit
                'this' from their enclosing lexical scope.</li>
            <li><strong>Explicit Binding:</strong> Using `.call()`, `.apply()`, and `.bind()` to explicitly set the
                value of 'this'.</li>
        </ul>
        <p><strong>Important Questions:</strong></p>
        <ul style="list-style: none;;">
            <li>What is the value of 'this' in the global scope?</li>
            <li>
                <details>
                    <summary>
                        How does an arrow function handle 'this' differently from a regular function?
                    </summary>
                    <h4>Regular Functions</h4>
                    <p>
                    <ul>
                        <li>In a regular function, the value of this is dynamic — it depends on how the function is
                            called.
                        </li>
                        <li>If called as a method of an object, this refers to that object.
                        </li>
                        <li>If called as a standalone function (in non–strict mode), this refers to the global object
                            (window in browsers, global in Node.js). In strict mode, it’s undefined.
                        </li>
                        <li>You can change this using .call(), .apply(), or .bind().</li>
                    </ul>
                    </p>
                    <h3>Example:</h3>
                    <pre>
                        <code>
 const obj = {
  value: 42,
  regularFunc: function () {
    console.log(this.value);
  }
};

obj.regularFunc(); // 42
const fn = obj.regularFunc;
fn(); // undefined (or global object in non-strict mode)

                        </code>
                    </pre>


                    <h3>Arrow Functions</h3>
                    <ul>
                        <li>Arrow functions do not have their own this.</li>
                        <li>Instead, they lexically inherit this from the surrounding scope (the scope in which they
                            were defined).</li>
                        <li>You cannot change their this with .call(), .apply(), or .bind() — they ignore it.</li>
                    </ul>

                </details>
            </li>
            <li>
                <details>
                    <summary>
                        Explain the difference between `call`, `apply`, and `bind`.
                    </summary>
                    <h4>1. call()</h4>

                </details>
            </li>
            <li>What will `console.log(this)` output in a method, a simple function, and an arrow function inside a
                method?</li>
        </ul>
    </div>

    <div class="concept">
        <h2>Prototypes and Prototypal Inheritance</h2>
        <p><strong>Brief Details:</strong></p>
        <p>JavaScript objects have a special hidden property `[[Prototype]]` (exposed as `__proto__`) that is either
            `null` or references another object. This referenced object is called a "prototype". When you try to access
            a property of an object, if the property isn't found on the object itself, the JavaScript engine looks for
            the property on its prototype, then the prototype's prototype, and so on, until it finds the property or
            reaches the end of the prototype chain (`null`). This is the basis of inheritance in JavaScript.</p>
        <p><strong>Example:</strong></p>
        <pre><code class="language-javascript">const animal = {
    eats: true
};
const rabbit = {
    jumps: true
};
Object.setPrototypeOf(rabbit, animal); // Preferred over __proto__
console.log(rabbit.eats); // true (inherited from animal)</code></pre>
        <p><strong>Important Questions:</strong></p>
        <ul>
            <li>What is prototypal inheritance? How does it differ from classical inheritance?</li>
            <li>What is the prototype chain?</li>
            <li>What is the difference between `__proto__` and `prototype`?</li>
            <li>How would you create an object that inherits from another object? (e.g., `Object.create()`)</li>
        </ul>
    </div>

    <div class="concept">
        <h2>Asynchronous JavaScript (Callbacks, Promises, async/await)</h2>
        <p><strong>Brief Details:</strong></p>
        <p>JavaScript is single-threaded, meaning it can only do one thing at a time. Asynchronous operations allow
            tasks (like fetching data from a server) to run in the background without blocking the main thread.</p>
        <ul>
            <li><strong>Callbacks:</strong> A function passed as an argument to another function, which is then executed
                after an async operation has completed. Can lead to "callback hell".</li>
            <li><strong>Promises:</strong> An object representing the eventual completion or failure of an asynchronous
                operation. Allows for cleaner handling of async operations with `.then()`, `.catch()`, and `.finally()`.
            </li>
            <li><strong>async/await:</strong> Syntactic sugar built on top of Promises that makes asynchronous code look
                and behave more like synchronous code.</li>
        </ul>
        <p><strong>Important Questions:</strong></p>
        <ul style="list-style-type: none;">
            <li>
                <details>
                    <summary>What is "callback hell" and how can you avoid it?</summary>
                    <p>Callback hell, also known as the "Pyramid of Doom," occurs when multiple nested callbacks in
                        JavaScript lead to code that is difficult to read and maintain.</p>
                    <pre>
                        <code>
getUserData(userId, function (userData) {
    getProfile(userData.id, function (profile) {
        getPreferences(profile.id, function (preferences) {
            updateSettings(preferences, function (settings) {
                saveToDatabase(settings, function (result) {
                    sendNotification(result, function (notification) {
                        console.log("All done!");
                    });
                });
            });
        });
    });
});
                        </code>
                    </pre>
                    <h5>How to Avoid Callback Hell</h5>
                    <p>
                        To mitigate the issues associated with callback hell, developers can use several strategies:
                        Promises: Promises allow you to handle asynchronous operations more cleanly by chaining .then()
                        methods, which flattens the structure and centralizes error handling. For example:

                    <pre>
                            <code>
  getUserData(userId)
 .then(userData => getProfile(userData.id))
 .then(profile => getPreferences(profile.id))
 .then(preferences => updateSettings(preferences))
 .then(settings => saveToDatabase(settings))
 .then(result => sendNotification(result))
 .then(() => console.log("All done!"))
 .catch(error => console.error("Error:", error));                                                                                                                                                                                                                                                     
                            </code>
                        </pre>
                    </p>

                    <p><strong>Async/Await:</strong> Introduced in ES2017, async/await syntax allows you to write
                        asynchronous code that looks synchronous, making it easier to read and maintain. Here’s how the
                        previous example would look using async/await:</p>
                    <pre>
                        <code>
 async function processUserData(userId) {
    try {
        const userData = await getUserData(userId);
        const profile = await getProfile(userData.id);
        const preferences = await getPreferences(profile.id);
        const settings = await updateSettings(preferences);
        const result = await saveToDatabase(settings);
        await sendNotification(result);
        console.log("All done!");
    } catch (error) {
        console.error("Error:", error);
    }
}
                        </code>
                    </pre>
                    <p>
                        <strong>Modularization:</strong> Break down complex functions into smaller, reusable functions.
                        This not only improves readability but also makes it easier to test and maintain individual
                        components of your code.
                    </p>
                    <p>
                        <strong>Control Flow Libraries:</strong> Libraries like Async.js can help manage asynchronous
                        control flow, providing functions to handle parallel and sequential execution without deeply
                        nested callbacks.By implementing these strategies, developers can avoid callback hell and write
                        cleaner, more maintainable code that is easier to understand and debug.
                    </p>
                </details>
            </li>

            <li>
                <details>
                    <summary>What is a Promise? Describe its states.</summary>
                    <p>
                        A Promise in JavaScript is an object that represents the eventual completion (or failure) of an
                        asynchronous operation and its resulting value.

                        It acts as a placeholder for a value that will be available now, later, or never.Why Promises?
                        Before Promises, asynchronous operations were often handled with callbacks, which could lead to
                        callback hell. Promises provide a cleaner, more manageable way to handle async code.

                        Promise States
                        A Promise has three main states:

                        Pending

                        Initial state, neither fulfilled nor rejected.
                        The async operation is still in progress.
                        Example: Waiting for a network request to complete.
                        Fulfilled (Resolved)

                        The operation completed successfully.
                        The Promise now has a value.
                        Handled with .then().
                        Rejected

                        The operation failed.
                        The Promise has a reason (error).
                        Handled with .catch().
                        State Transition Rules
                        A Promise starts in pending.
                        It can move to fulfilled with a value, or to rejected with a reason.
                        Once fulfilled or rejected, it becomes settled and cannot change state again.
                        Example
                    </p>
                    <pre>
                        <code>
                            // Creating a Promise
const myPromise = new Promise((resolve, reject) => {
    let success = true;

    setTimeout(() => {
        if (success) {
            resolve("Data loaded successfully!"); // Fulfilled
        } else {
            reject("Error loading data."); // Rejected
        }
    }, 1000);
});

// Consuming a Promise
myPromise
    .then(result => {
        console.log("✅ Success:", result);
    })
    .catch(error => {
        console.error("❌ Error:", error);
    })
    .finally(() => {
        console.log("Promise settled (fulfilled or rejected).");
    });

                        </code>
                    </pre>
                    <p>
                    <pre>
                            <code>
                                
                               <table style="align-self: center;" border="1" cellpadding="5" cellspacing="0">
    <thead>
        <tr>
            <th>State</th>
            <th>Meaning</th>
            <th>Can Change To</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Pending</td>
            <td>Operation in progress</td>
            <td>Fulfilled / Rejected</td>
        </tr>
        <tr>
            <td>Fulfilled</td>
            <td>Operation succeeded</td>
            <td>❌ Cannot change</td>
        </tr>
        <tr>
            <td>Rejected</td>
            <td>Operation failed</td>
            <td>❌ Cannot change</td>
        </tr>
    </tbody>
</table>

                            </code>
                        </pre>
                    </p>
                </details>
            </li>
            <li>
                <details>
                    <summary>What are `Promise.all()`, `Promise.race()`, and `Promise.allSettled()`? When would you use
                        them?</summary>
                    <h4>1. Promise.all()</h4>
                    <p>Purpose:
                        Runs multiple promises in parallel and waits until all of them are fulfilled.
                        If any promise rejects, the entire Promise.all() rejects immediately.</p>
                    <pre><code>
  ------------//Stynax//-----------------
    Promise.all([promise1, promise2, promise3])
  .then(results => console.log(results)) // Array of resolved values
  .catch(error => console.error(error)); // First rejection reason

//Example 
const p1 = Promise.resolve(10);
const p2 = Promise.resolve(20);
const p3 = Promise.resolve(30);

Promise.all([p1, p2, p3])
  .then(values => console.log(values)) // [10, 20, 30]
  .catch(err => console.error(err));
</code></pre>
                    <h5>When to use:</h5>
                    <ul>
                        <li>When all tasks must succeed before proceeding.</li>
                        <li>Example: Fetching multiple API endpoints where all data is required.</li>
                    </ul>

                    <h4>
                        2. Promise.race()
                    </h4>
                    <p>
                        <strong>
                            Purpose:
                        </strong>
                        Runs multiple promises in parallel and settles (resolves or rejects) as soon as the first
                        promise settles.
                    </p>
                    <pre>
    <code>
Promise.race([promise1, promise2, promise3])
  .then(result => console.log(result)) // First resolved value
  .catch(error => console.error(error)); // First rejection reason</code>
</pre>
                    <h5><Strong>Example</Strong></h5>
                    <pre><code>
const p1 = new Promise(res => setTimeout(() => res("First"), 100));
const p2 = new Promise(res => setTimeout(() => res("Second"), 200));

Promise.race([p1, p2])
  .then(value => console.log(value)); // "First"
</code></pre>
                    <h5>
                        When to use:
                    </h5>
                    <ul>
                        <li>When you only care about the fastest result.</li>
                        <li>Example: Implementing a timeout for an API request.</li>
                    </ul>
                    <h4>
                        3. Promise.allSettled()
                    </h4>
                    <strong>
                        Purpose:

                    </strong>
                    <p>Runs multiple promises in parallel and waits until all have settled (either fulfilled or
                        rejected).
                        It never short-circuits on rejection.</p>

                    <strong>Syntax:</strong>
                    <pre>
    <code>
  Promise.allSettled([promise1, promise2, promise3])
  .then(results => console.log(results)); // Array of {status, value/reason}

    </code>
</pre>
                    <strong>Example</strong>
                    <pre><code>
const p1 = Promise.resolve(10);
const p2 = Promise.reject("Error");
const p3 = Promise.resolve(30);

Promise.allSettled([p1, p2, p3])
  .then(results => console.log(results));
/*
[
  { status: "fulfilled", value: 10 },
  { status: "rejected", reason: "Error" },
  { status: "fulfilled", value: 30 }
]
*/

</code></pre>

                    <h5><strong>When to use:</strong></h5>

                    <ul>
                        <li>When you want all results, regardless of success or failure.</li>
                        <li>Example: Running multiple independent API calls and collecting both successes and failures.
                        </li>

                    </ul>
                    <table border="1" cellpadding="5" cellspacing="0">
                        <thead>
                            <tr>
                                <th>Method</th>
                                <th>Waits for all?</th>
                                <th>Stops on first reject?</th>
                                <th>Returns on settle?</th>
                                <th>Use case</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Promise.all()</td>
                                <td>✅ Yes</td>
                                <td>✅ Yes</td>
                                <td>❌ No</td>
                                <td>All must succeed</td>
                            </tr>
                            <tr>
                                <td>Promise.race()</td>
                                <td>❌ No</td>
                                <td>✅ Yes (if first rejects)</td>
                                <td>✅ Yes</td>
                                <td>First result wins</td>
                            </tr>
                            <tr>
                                <td>Promise.allSettled()</td>
                                <td>✅ Yes</td>
                                <td>❌ No</td>
                                <td>✅ Yes</td>
                                <td>Get all outcomes</td>
                            </tr>
                        </tbody>
                    </table>

                </details>
            </li>
            <li>
                <details>
                    <summary>What is the difference between `async/await` and using `.then()`?</summary>
                    <table border="1" cellpadding="5" cellspacing="0">
                        <thead>
                            <tr>
                                <th>Feature</th>
                                <th>.then()</th>
                                <th>async/await</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Style</td>
                                <td>Promise chaining (callback-based)</td>
                                <td>Synchronous-looking code for async operations</td>
                            </tr>
                            <tr>
                                <td>Error Handling</td>
                                <td>.catch() or second .then() argument</td>
                                <td>try...catch blocks</td>
                            </tr>
                            <tr>
                                <td>Readability</td>
                                <td>Can become nested and harder to follow with many steps</td>
                                <td>Cleaner, more linear flow</td>
                            </tr>
                            <tr>
                                <td>Return Value</td>
                                <td>Returns a new Promise</td>
                                <td>Returns a Promise automatically from an async function</td>
                            </tr>
                            <tr>
                                <td>When Introduced</td>
                                <td>ES6 (2015)</td>
                                <td>ES2017</td>
                            </tr>
                        </tbody>
                    </table>

                </details>
            </li>
            <li>
                <details>
                    <summary>
                        How do you handle errors in Promises and with `async/await`?
                    </summary>

                    <h4>
                        1. Handling Errors in Promises (.then() / .catch())
                    </h4>
                    <pre>
                    <code>
fetch('https://api.example.com/data')
    .then(response => {
        if (!response.ok) throw new Error('Network error');
        return response.json();
    })
    .then(data => {
        console.log('Data:', data);
    })
    .catch(error => {
        console.error('Caught error:', error);
    });

                    </code>
                </pre>
                    <h3><strong>
                            How it works:
                        </strong></h3>
                    <ul>
                        <li>
                            Any rejected promise or error thrown in .then() will skip to the nearest .catch().
                        </li>
                        <li>
                            .catch() at the end of the chain handles all errors from above.
                        </li>
                    </ul>
                    <h3>
                        <strong>
                            2. Handling Errors with async/await
                        </strong>
                    </h3>
                    <h5>
                        Using try...catch
                    </h5>
                    <pre>
            <code>
 async function getData() {
try {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) throw new Error('Network error');
    const data = await response.json();
    console.log('Data:', data);
} catch (error) {
    console.error('Caught error:', error);
}

 }
getData();

            </code>
        </pre>
                    <h4>
                        <strong>
                            How it works:
                        </strong>
                    </h4>

                    <ul>
                        <li>Wrap await calls in try...catch to handle both thrown errors and promise rejections.
                        </li>
                        <li>This makes async code look synchronous and easier to read.</li>
                    </ul>

                    <h3>
                        Catching Outside the Async Function
                    </h3>
                    <pre>
                        <code>
async function getData() {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) throw new Error('Network error');
    return response.json();
}

getData()
    .then(data => console.log(data))
    .catch(err => console.error('Caught outside:', err));

                        </code>
                    </pre>
                </details>


            </li>
        </ul>
    </div>

    <div class="concept">
        <h2>Event Loop</h2>
        <p><strong>Brief Details:</strong></p>
        <p>The Event Loop is the mechanism that enables non-blocking asynchronous operations in JavaScript. It consists
            of the Call Stack, the Callback Queue (or Task Queue), and Web APIs.</p>
        <ul>
            <li>The Event Loop continuously checks if the Call Stack is empty. If it is, it takes the first message from
                the Callback Queue and pushes it onto the Call Stack to be executed.</li>
        </ul>
        <p><strong>Important Questions:</strong></p>
        <ul>
            <li>What is the Event Loop? Explain its components.</li>
            <li>What is the difference between the Call Stack and the Callback Queue?</li>
            <li>What will be the output of `setTimeout(() => console.log('A'), 0); console.log('B');` and why?</li>
            <li>What is the difference between microtasks (e.g., Promise callbacks) and macrotasks (e.g., `setTimeout`)?
                Which one has higher priority?</li>
        </ul>
    </div>

    <div class="concept">
        <h2>Higher-Order Functions</h2>
        <p><strong>Brief Details:</strong></p>
        <p>A higher-order function is a function that either takes one or more functions as arguments, or returns a
            function as its result, or both. JavaScript's array methods like `map`, `filter`, and `reduce` are common
            examples.</p>
        <p><strong>Example:</strong></p>
        <pre><code class="language-javascript">function multiplier(factor) {
    return function(number) { // Returns a function
        return number * factor;
    };
}
const double = multiplier(2);
console.log(double(5)); // 10</code></pre>
        <p><strong>Important Questions:</strong></p>
        <ul>
            <li>What is a higher-order function?</li>
            <li>Can you implement your own version of `Array.prototype.map`?</li>
            <li>Explain what `Array.prototype.reduce` does. Provide a use case other than summing numbers.</li>
            <li>What are the benefits of using higher-order functions?</li>
        </ul>
    </div>

    <div class="concept">
        <h2>Currying</h2>
        <p><strong>Brief Details:</strong></p>
        <p>Currying is a functional programming technique of transforming a function that takes multiple arguments into
            a sequence of functions that each take a single argument.</p>
        <p><strong>Example:</strong></p>
        <pre><code class="language-javascript">const add = (a, b) => a + b; // Non-curried
const curriedAdd = (a) => (b) => a + b; // Curried
const add5 = curriedAdd(5);
console.log(add5(3)); // 8</code></pre>
        <p><strong>Important Questions:</strong></p>
        <ul>
            <li>What is currying? What are its benefits?</li>
            <li>What's the difference between currying and partial application?</li>
            <li>How can you create a generic `curry` function that converts any multi-argument function?</li>
        </ul>
    </div>

    <div class="concept">
        <h2>Memoization</h2>
        <p><strong>Brief Details:</strong></p>
        <p>Memoization is an optimization technique used to speed up function calls by caching the results of expensive
            function calls and returning the cached result when the same inputs occur again.</p>
        <p><strong>Example:</strong></p>
        <pre><code class="language-javascript">function memoize(fn) {
    const cache = {};
    return function(...args) {
        const key = JSON.stringify(args);
        if (cache[key]) {
            return cache[key];
        } else {
            const result = fn(...args);
            cache[key] = result;
            return result;
        }
    }
}
const slowFunction = (num) => { /* ... expensive calculation ... */ return num * 2; };
const fastFunction = memoize(slowFunction);</code></pre>
        <p><strong>Important Questions:</strong></p>
        <ul>
            <li>What is memoization and when is it useful?</li>
            <li>Implement a `memoize` higher-order function.</li>
            <li>What are the potential drawbacks of memoization (e.g., memory consumption)?</li>
        </ul>
    </div>

    <div class="concept">
        <h2>Generators and Iterators</h2>
        <p><strong>Brief Details:</strong></p>
        <p>The iterator protocol defines a standard way to produce a sequence of values. A Generator function
            (`function*`) is a special function that simplifies writing iterators. It can pause its execution using the
            `yield` keyword and resume later.</p>
        <p><strong>Example:</strong></p>
        <pre><code class="language-javascript">function* idGenerator() {
    let id = 1;
    while (true) {
        yield id++;
    }
}
const gen = idGenerator();
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2</code></pre>
        <p><strong>Important Questions:</strong></p>
        <ul>
            <li>What is the difference between an iterator and a generator?</li>
            <li>What does the `yield` keyword do?</li>
            <li>Provide a practical use case for a generator function (e.g., handling large data sets).</li>
        </ul>
    </div>

    <div class="concept">
        <h2>Interview Context (Companies)</h2>
        <p>The topics covered in this file are fundamental to modern JavaScript development and are frequently brought
            up in technical interviews for mid-level and senior software engineering roles.</p>
        <ul>
            <li>FAANG (Facebook/Meta, Amazon, Apple, Netflix, Google) and other top tech companies often test these
                concepts to gauge a candidate's depth of understanding of JavaScript's core mechanics.</li>
            <li>Questions about closures, `this`, and async programming are particularly common as they are crucial for
                writing robust, scalable, and maintainable code.</li>
            <li>A solid grasp of these advanced topics demonstrates that a candidate can move beyond basic
                library/framework usage and understand how the language itself works, which is a key indicator of a
                strong developer.</li>
        </ul>
    </div>

    <h1>JavaScript Implementation Challenges</h1>

    <div class="concept">
        <h2>Debounce</h2>
        <p><strong>Concept:</strong> Debouncing is a programming practice used to ensure that time-consuming tasks do
            not fire so often, that it stalls the performance of the web page. In other words, it limits the rate at
            which a function gets triggered.</p>
        <p><strong>Implementation:</strong></p>
        <pre><code class="language-javascript">function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        // Clear the previous timeout
        clearTimeout(timeoutId);
        // Set a new timeout
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}

// Example Usage:
window.addEventListener('resize', debounce(() => {
    console.log('Window resized!');
}, 300));</code></pre>
    </div>

    <div class="concept">
        <h2>Implement Array.prototype Functions</h2>
        <p><strong>Array.prototype.map()</strong></p>
        <pre><code class="language-javascript">Array.prototype.myMap = function(callback) {
    const newArray = [];
    for (let i = 0; i < this.length; i++) {
        if (this.hasOwnProperty(i)) { // Check for sparse arrays
             newArray.push(callback(this[i], i, this));
        }
    }
    return newArray;
};</code></pre>
        <p><strong>Array.prototype.filter()</strong></p>
        <pre><code class="language-javascript">Array.prototype.myFilter = function(callback) {
    const newArray = [];
    for (let i = 0; i < this.length; i++) {
        if (this.hasOwnProperty(i) && callback(this[i], i, this)) {
            newArray.push(this[i]);
        }
    }
    return newArray;
};</code></pre>
        <p><strong>Array.prototype.reduce()</strong></p>
        <pre><code class="language-javascript">Array.prototype.myReduce = function(callback, initialValue) {
    let accumulator = initialValue;
    let startIndex = 0;
    if (initialValue === undefined) {
        // Find the first defined index in sparse arrays
        for(let i = 0; i<this.length; i++){
            if(this.hasOwnProperty(i)){
                accumulator = this[i];
                startIndex = i + 1;
                break;
            }
        }
    }

    for (let i = startIndex; i < this.length; i++) {
        if (this.hasOwnProperty(i)) {
            accumulator = callback(accumulator, this[i], i, this);
        }
    }
    return accumulator;
};</code></pre>
    </div>

    <div class="concept">
        <h2>Implement Promise-based APIs</h2>
        <p><strong>Promise.all()</strong></p>
        <pre><code class="language-javascript">function promiseAll(promises) {
    return new Promise((resolve, reject) => {
        const results = [];
        let completed = 0;
        if (promises.length === 0) {
            resolve(results);
            return;
        }
        promises.forEach((promise, index) => {
            Promise.resolve(promise).then(value => {
                results[index] = value;
                completed++;
                if (completed === promises.length) {
                    resolve(results);
                }
            }).catch(reject);
        });
    });
}</code></pre>
    </div>

    <div class="concept">
        <h2>Implement Lodash Functions</h2>
        <p><strong>_.cloneDeep()</strong></p>
        <pre><code class="language-javascript">function cloneDeep(value) {
    if (typeof value !== 'object' || value === null) {
        return value;
    }
    
    const newObject = Array.isArray(value) ? [] : {};
    
    for (const key in value) {
        // Use Object.prototype.hasOwnProperty.call for safety
        if (Object.prototype.hasOwnProperty.call(value, key)) {
            newObject[key] = cloneDeep(value[key]);
        }
    }
    
    return newObject;
}</code></pre>
        <p><strong>_.groupBy()</strong></p>
        <pre><code class="language-javascript">function groupBy(collection, iteratee) {
    return collection.reduce((acc, item) => {
        const key = typeof iteratee === 'function' ? iteratee(item) : item[iteratee];
        if (!acc[key]) {
            acc[key] = [];
        }
        acc[key].push(item);
        return acc;
    }, {});
}</code></pre>
    </div>

    <h1>Core JavaScript Concepts</h1>

    <div class="concept">
        <h2>Hoisting</h2>
        <p>Hoisting is JavaScript's default behavior of moving declarations to the top of the current scope (script or
            function). `var` variables are hoisted and initialized with `undefined`. `let` and `const` variables are
            hoisted but not initialized, which puts them in a "temporal dead zone" until the declaration is encountered.
        </p>
        <pre><code class="language-javascript">console.log(myVar); // undefined
var myVar = 5;

// vs

// console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization
let myLet = 10;</code></pre>
    </div>

    <div class="concept">
        <h2>Event Bubbling and Capturing</h2>
        <p>Event propagation in the DOM has two main phases:
        <ol>
            <li><strong>Capturing Phase:</strong> The event travels from the root of the document down to the target
                element.</li>
            <li><strong>Bubbling Phase:</strong> The event travels or "bubbles" up from the target element back to the
                root.</li>
        </ol>
        By default, event handlers are executed in the bubbling phase. You can listen in the capturing phase by passing
        `{ capture: true }` to `addEventListener`.
        </p>
    </div>

    <div class="concept">
        <h2>Event Delegation</h2>
        <p>Event delegation is a technique where you add a single event listener to a parent element to manage events
            for all of its children. When an event bubbles up from a child to the parent, the parent's listener can
            check the `event.target` property to determine which child element originated the event. This is more
            efficient than adding an event listener to every child, especially for dynamic lists.</p>
        <pre><code class="language-javascript">// Instead of adding a listener to every <li>...
document.getElementById('myList').addEventListener('click', function(e) {
    if (e.target && e.target.matches('li.item')) {
        console.log('List item clicked:', e.target.textContent);
    }
});</code></pre>
    </div>

    <div class="concept">
        <h2>"use strict"</h2>
        <p><code>"use strict";</code> is a directive that enables "strict mode" in JavaScript. Strict mode makes several
            changes to normal JavaScript semantics:</p>
        <ul>
            <li>Eliminates some JavaScript silent errors by changing them to throw errors.</li>
            <li>Fixes mistakes that make it difficult for JavaScript engines to perform optimizations.</li>
            <li>Prohibits some syntax likely to be defined in future versions of ECMAScript.</li>
            <li>Forbids assigning values to undeclared variables.</li>
        </ul>
        <p>It's generally recommended for writing robust and secure JavaScript.</p>
    </div>

    <div class="concept">
        <h2>Mutable vs. Immutable Objects</h2>
        <p>
            <strong>Mutable</strong> objects are those whose state can be modified after they are created. In
            JavaScript, objects and arrays are mutable.
            <br>
            <strong>Immutable</strong> objects are those whose state cannot be changed after creation. In JavaScript,
            primitive types (string, number, boolean, null, undefined, symbol, bigint) are immutable.
        </p>
        <pre><code class="language-javascript">let arr = [1, 2];
arr.push(3); // Mutates the original array: arr is now [1, 2, 3]

let str = "hello";
str.toUpperCase(); // Does not mutate 'str'. It returns a new string "HELLO".
console.log(str); // "hello"</code></pre>
    </div>

    <h1>Quick Questions & Comparisons</h1>

    <div class="concept">
        <h2>AMD vs. CommonJS</h2>
        <p>Both are module systems for JavaScript, but they have different approaches:</p>
        <ul>
            <li><strong>CommonJS (CJS):</strong> Synchronous. Modules are loaded at runtime, one by one. It was designed
                for server-side JavaScript (like Node.js). `require()` and `module.exports`.</li>
            <li><strong>Asynchronous Module Definition (AMD):</strong> Asynchronous. Modules are loaded in parallel,
                which is better for browsers as it doesn't block rendering. `define()` function.</li>
        </ul>
        <p>Modern JavaScript has adopted ES Modules (`import`/`export`), which is now the standard and offers the best
            of both worlds.</p>
    </div>

    <div class="concept">
        <h2>IIFE (Immediately Invoked Function Expression) Problem</h2>
        <p>The code <code>function foo(){ }();</code> doesn't work because it's parsed as a function declaration, not an
            expression. The `()` afterwards is seen as a syntax error.</p>
        <p>To fix it, you need to trick the parser into treating it as an expression. The most common way is to wrap it
            in parentheses:</p>
        <pre><code class="language-javascript">(function foo(){
    console.log('IIFE works!');
})();</code></pre>
    </div>

    <div class="concept">
        <h2><code>null</code> vs. <code>undefined</code> vs. <code>undeclared</code></h2>
        <ul>
            <li><strong><code>undeclared</code>:</strong> A variable that has not been declared at all. Trying to access
                it results in a `ReferenceError`.</li>
            <li><strong><code>undefined</code>:</strong> A variable that has been declared but has not been assigned a
                value. It is a primitive type.</li>
            <li><strong><code>null</code>:</strong> A variable that is explicitly assigned the value `null`. It
                represents the intentional absence of any object value. It is also a primitive type.</li>
        </ul>
        <p><strong>Checking for them:</strong></p>
        <pre><code class="language-javascript">if (typeof myVar === 'undefined') { /* checks for undefined or undeclared */ }

if (myVar === null) { /* checks specifically for null */ }

// Using == null checks for both null and undefined
if (myVar == null) { /* true if myVar is null or undefined */ }
</code></pre>
    </div>

    <div class="concept">
        <h2><code>.forEach()</code> vs. <code>.map()</code></h2>
        <ul>
            <li><strong><code>.forEach()</code>:</strong> Executes a provided function once for each array element. It
                does <strong>not</strong> return a new array (it returns `undefined`). Use it when you want to perform a
                side effect for each element (e.g., logging to console, saving to a database).</li>
            <li><strong><code>.map()</code>:</strong> Creates a <strong>new array</strong> populated with the results of
                calling a provided function on every element in the calling array. Use it when you want to transform an
                array into a new array.</li>
        </ul>
    </div>

    <div class="concept">
        <h2><code>==</code> vs. <code>===</code></h2>
        <ul>
            <li><strong><code>==</code> (Loose Equality):</strong> Compares two values for equality after performing
                type conversion if necessary.</li>
            <li><strong><code>===</code> (Strict Equality):</strong> Compares two values for equality without performing
                type conversion. They must be of the same type and have the same value.</li>
        </ul>
        <p>It's almost always better to use `===` to avoid unexpected behavior from type coercion.</p>
        <pre><code class="language-javascript">5 == '5';  // true
5 === '5'; // false</code></pre>
    </div>

    <div class="concept">
        <h2><code>.call()</code> vs. <code>.apply()</code> vs. <code>.bind()</code></h2>
        <p>All three methods are used to set the `this` value when calling a function.</p>
        <ul>
            <li><strong><code>.call(thisArg, arg1, arg2, ...)</code>:</strong> Invokes the function immediately, passing
                arguments individually.</li>
            <li><strong><code>.apply(thisArg, [arg1, arg2, ...])</code>:</strong> Invokes the function immediately,
                passing arguments as an array.</li>
            <li><strong><code>.bind(thisArg)</code>:</strong> Returns a <strong>new function</strong> with `this` bound
                to `thisArg`. The new function can be called later.</li>
        </ul>
    </div>

    <div class="concept">
        <h2>ES6 Class vs. ES5 Function Constructors</h2>
        <p>ES6 `class` is primarily syntactic sugar over ES5's prototypal inheritance model.</p>
        <ul>
            <li><strong>Clarity:</strong> `class` syntax is clearer and more familiar to developers from class-based
                languages.</li>
            <li><strong>Hoisting:</strong> Function constructors are hoisted, while class declarations are not.</li>
            <li><strong>Strict Mode:</strong> Code inside a class body is always in strict mode.</li>
        </ul>
    </div>

    <h1>ES6+ Features</h1>

    <div class="concept">
        <h2><code>let</code>, <code>var</code>, and <code>const</code></h2>
        <ul>
            <li><strong><code>var</code>:</strong> Function-scoped. Variables declared with `var` are hoisted to the top
                of their function scope and initialized with `undefined`. Can be re-declared and updated.</li>
            <li><strong><code>let</code>:</strong> Block-scoped (`{}`). Variables are hoisted but not initialized
                (temporal dead zone). Can be updated but not re-declared within the same scope.</li>
            <li><strong><code>const</code>:</strong> Block-scoped. Also has a temporal dead zone. Cannot be updated or
                re-declared. For objects and arrays, the reference is constant, but the contents can be modified.</li>
        </ul>
    </div>

    <div class="concept">
        <h2>Arrow Functions (<code>=&gt;</code>)</h2>
        <p>Arrow functions provide a more concise syntax for writing function expressions. The main difference from
            regular functions is how they handle `this`.</p>
        <ul>
            <li><strong>Lexical `this`:</strong> Arrow functions do not have their own `this` binding. They inherit
                `this` from the parent scope at the time they are defined.</li>
            <li><strong>Use Case in Constructors:</strong> This makes them useful for methods in constructors that need
                to access the instance's `this` inside callbacks, without needing `.bind(this)`.</li>
        </ul>
        <pre><code class="language-javascript">function Timer() {
    this.seconds = 0;
    setInterval(() => {
        this.seconds++; // 'this' correctly refers to the Timer instance
    }, 1000);
}
const timer = new Timer();</code></pre>
    </div>

    <div class="concept">
        <h2>Destructuring Assignment</h2>
        <p>Destructuring is a syntax that makes it possible to unpack values from arrays, or properties from objects,
            into distinct variables.</p>
        <p><strong>Object Destructuring:</strong></p>
        <pre><code class="language-javascript">const user = { firstName: 'John', lastName: 'Doe' };
const { firstName, lastName } = user;
console.log(firstName); // John</code></pre>
        <p><strong>Array Destructuring:</strong></p>
        <pre><code class="language-javascript">const [a, b] = [10, 20];
console.log(a); // 10</code></pre>
    </div>

    <div class="concept">
        <h2>Template Literals</h2>
        <p>Template literals are string literals allowing embedded expressions. You can use multi-line strings and
            string interpolation features with them.</p>
        <pre><code class="language-javascript">const name = "World";
const greeting = `Hello, ${name}!
This is a multi-line string.`;
console.log(greeting);</code></pre>
    </div>

    <div class="concept">
        <h2>Spread vs. Rest Syntax (<code>...</code>)</h2>
        <p>The `...` syntax is used for both spread and rest, but in different contexts.</p>
        <ul>
            <li><strong>Spread Syntax:</strong> "expands" an iterable (like an array or string) into individual
                elements. It's often used for making shallow copies of arrays/objects or merging them.</li>
            <li><strong>Rest Syntax:</strong> "collects" multiple elements and "condenses" them into a single array.
                It's used in function parameters to gather all remaining arguments into an array.</li>
        </ul>
        <pre><code class="language-javascript">// Spread
const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5]; // [1, 2, 3, 4, 5]

// Rest
function sum(...numbers) {
    return numbers.reduce((acc, current) => acc + current, 0);
}
console.log(sum(1, 2, 3, 4)); // 10</code></pre>
    </div>

    <div class="concept">
        <h2>Static Class Members</h2>
        <p>Static methods and properties are defined on the class itself, not on the instances of the class. You would
            create static members when the method or property is related to the class as a whole, but not to any
            specific instance. They are often used for creating utility functions or constants related to the class.</p>
        <pre><code class="language-javascript">class MyClass {
    static staticProperty = 'Some Value';
    static staticMethod() {
        return 'Hello from static method!';
    }
}

console.log(MyClass.staticProperty);      // 'Some Value'
console.log(MyClass.staticMethod());    // 'Hello from static method!'
// const instance = new MyClass();
// console.log(instance.staticMethod()); // TypeError</code></pre>
    </div>

    <h1>DOM, Async, and Development</h1>

    <div class="concept">
        <h2>Same-Origin Policy</h2>
        <p>The same-origin policy is a critical security mechanism that restricts how a document or script loaded from
            one "origin" can interact with a resource from another "origin". An origin is defined by the combination of
            protocol (e.g., `http`), host (e.g., `example.com`), and port (e.g., `80`). This policy prevents malicious
            scripts on one page from obtaining sensitive data from another web page through DOM manipulation.</p>
    </div>

    <div class="concept">
        <h2>Ajax (Asynchronous JavaScript and XML)</h2>
        <p>Ajax is a set of web development techniques that allows a web page to update asynchronously by exchanging
            small amounts of data with the server behind the scenes. This means you can update parts of a web page
            without reloading the whole page.</p>
        <ul>
            <li><strong>How it works:</strong> An `XMLHttpRequest` (or more modern `fetch` API) object is used to send a
                request to a server URL. The server processes the request and sends back a response (typically as JSON,
                not XML anymore), which is then used by the client-side JavaScript to update the DOM.</li>
            <li><strong>Advantages:</strong> Improved user experience (no full page reloads), reduced bandwidth usage.
            </li>
            <li><strong>Disadvantages:</strong> Can be complex to manage state, can break browser's back button if not
                handled carefully (e.g., with the History API).</li>
        </ul>
    </div>

    <div class="concept">
        <h2>JSONP (JSON with Padding)</h2>
        <p>JSONP is a technique used to overcome the same-origin policy's restrictions on making requests to different
            domains. It is not "real" Ajax because it doesn't use `XMLHttpRequest`.</p>
        <p>It works by dynamically creating a
        <p> tag on the page, whose `src` points to the cross-domain URL. The server then wraps the JSON response in a
            function call (the "padding"). Since browsers do not block script tags from cross-origin sources, the data
            can be received and processed. This is now largely superseded by CORS (Cross-Origin Resource Sharing)</p>.
        </p>
    </div>

    <div class="concept">
        <h2>Promises vs. Callbacks</h2>
        <p>Promises provide a more robust and flexible way to handle asynchronous operations compared to traditional
            callbacks.</p>
        <ul>
            <li><strong>Pros of Promises:</strong>
                <ul>
                    <li>Avoids "Callback Hell" and results in more readable, linear code (especially with
                        `async/await`).</li>
                    <li>Provides standardized, chainable `.then()` and `.catch()` methods for handling success and
                        failure.</li>
                    <li>Easier to compose multiple asynchronous operations (e.g., `Promise.all`).</li>
                </ul>
            </li>
            <li><strong>Cons of Promises:</strong> Can be slightly more complex to learn initially.</li>
        </ul>
    </div>

    <div class="concept">
        <h2>Code Organization & Debugging</h2>
        <ul>
            <li><strong>Organization:</strong> Modern JavaScript projects are typically organized using ES Modules
                (`import`/`export`) to create reusable, self-contained files. Design patterns like the Module Pattern
                (using closures) or class-based structures are also used.</li>
            <li><strong>Debugging:</strong> Key tools include:
                <ul>
                    <li>Browser DevTools (debugger, console, network tab).</li>
                    <li>Using the `debugger;` statement in code to create breakpoints.</li>
                    <li>`console.log()`, `console.warn()`, `console.error()`, `console.table()` for inspecting
                        variables.</li>
                    <li>Linters (like ESLint) to catch errors before runtime.</li>
                </ul>
            </li>
        </ul>
    </div>
</body>

</html>