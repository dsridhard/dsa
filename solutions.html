<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Solutions</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: #fff;
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #0056b3;
            margin-bottom: 30px;
        }
        h2 {
            color: #0056b3;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
            margin-top: 30px;
        }
        ul {
            list-style: none;
            padding: 0;
        }
        li {
            background: #fff;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }
        .question-header {
            padding: 15px;
            background-color: #f9f9f9;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
        }
        .question-header:hover {
            background-color: #f0f0f0;
        }
        details {
            width: 100%;
        }
        summary {
            list-style: none;
            outline: none;
        }
        summary::-webkit-details-marker {
            display: none;
        }
        .solution-content {
            padding: 15px;
            background-color: #282c34;
            color: #abb2bf;
            border-top: 1px solid #ddd;
            overflow-x: auto;
        }
        pre {
            margin: 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        .nav-btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: #0056b3;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.3s;
            margin-right: 10px;
        }
        .nav-btn:hover {
            background-color: #004494;
        }
        .controls {
            margin-bottom: 20px;
        }
        .badge {
            font-size: 0.8em;
            background-color: #e0e0e0;
            padding: 2px 8px;
            border-radius: 12px;
            color: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <a href="./index.html" class="nav-btn">Back to Questions</a>
        </div>
        <h1>DSA Solutions Repository</h1>

        <h2>Array</h2>
        <ul>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Check if pair with the given Sum exits in an array</span>
                        <span class="badge">Hashing</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)
// Space Complexity: O(N)

function hasPairWithSum(arr, target) {
    const seen = new Set();
    for (let num of arr) {
        if (seen.has(target - num)) {
            return true;
        }
        seen.add(num);
    }
    return false;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Best Time to buy and sell stock</span>
                        <span class="badge">Greedy</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)
// Space Complexity: O(1)

function maxProfit(prices) {
    let minPrice = Infinity;
    let maxProfit = 0;
    
    for (let price of prices) {
        if (price < minPrice) {
            minPrice = price;
        } else if (price - minPrice > maxProfit) {
            maxProfit = price - minPrice;
        }
    }
    return maxProfit;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Find duplicates</span>
                        <span class="badge">Floyd's Cycle</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)
// Space Complexity: O(1)

function findDuplicate(nums) {
    let slow = nums[0];
    let fast = nums[0];
    do {
        slow = nums[slow];
        fast = nums[nums[fast]];
    } while (slow !== fast);
    
    fast = nums[0];
    while (slow !== fast) {
        slow = nums[slow];
        fast = nums[fast];
    }
    return slow;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Products of array excepts self</span>
                        <span class="badge">Prefix & Suffix Products</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)
// Space Complexity: O(1) (excluding output array)

function productExceptSelf(nums) {
    const n = nums.length;
    const output = new Array(n).fill(1);
    let left = 1;
    for (let i = 0; i < n; i++) {
        output[i] = left;
        left *= nums[i];
    }
    let right = 1;
    for (let i = n - 1; i >= 0; i--) {
        output[i] *= right;
        right *= nums[i];
    }
    return output;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Maximum subarray (Kadane's Algorithm)</span>
                        <span class="badge">DP / Greedy</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)

function maxSubArray(nums) {
    let currentMax = nums[0];
    let globalMax = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        currentMax = Math.max(nums[i], currentMax + nums[i]);
        globalMax = Math.max(globalMax, currentMax);
    }
    return globalMax;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>maximum product subarray</span>
                        <span class="badge">Modified Kadaneâ€™s</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)

function maxProduct(nums) {
    let max = nums[0], min = nums[0], res = nums[0];
    for (let i = 1; i < nums.length; i++) {
        let temp = max;
        max = Math.max(nums[i], Math.max(nums[i] * max, nums[i] * min));
        min = Math.min(nums[i], Math.min(nums[i] * temp, nums[i] * min));
        res = Math.max(res, max);
    }
    return res;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Find Minimum in rotated sorted array</span>
                        <span class="badge">Modified Binary Search</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(log N)

function findMin(nums) {
    let l = 0, r = nums.length - 1;
    while (l < r) {
        let mid = Math.floor((l + r) / 2);
        if (nums[mid] > nums[r]) l = mid + 1;
        else r = mid;
    }
    return nums[l];
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>search in rotated sorted array</span>
                        <span class="badge">Modified Binary Search</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(log N)

function search(nums, target) {
    let l = 0, r = nums.length - 1;
    while (l <= r) {
        let mid = Math.floor((l + r) / 2);
        if (nums[mid] === target) return mid;
        if (nums[l] <= nums[mid]) {
            if (target >= nums[l] && target < nums[mid]) r = mid - 1;
            else l = mid + 1;
        } else {
            if (target > nums[mid] && target <= nums[r]) l = mid + 1;
            else r = mid - 1;
        }
    }
    return -1;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>3 Sum</span>
                        <span class="badge">Sorting + Two Pointers</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N^2)

function threeSum(nums) {
    nums.sort((a, b) => a - b);
    const res = [];
    for (let i = 0; i < nums.length - 2; i++) {
        if (i > 0 && nums[i] === nums[i-1]) continue;
        let l = i + 1, r = nums.length - 1;
        while (l < r) {
            const sum = nums[i] + nums[l] + nums[r];
            if (sum === 0) {
                res.push([nums[i], nums[l], nums[r]]);
                while (l < r && nums[l] === nums[l+1]) l++;
                while (l < r && nums[r] === nums[r-1]) r--;
                l++; r--;
            } else if (sum < 0) l++;
            else r--;
        }
    }
    return res;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Container with most Water</span>
                        <span class="badge">Two Pointers</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)

function maxArea(height) {
    let l = 0, r = height.length - 1;
    let max = 0;
    while (l < r) {
        max = Math.max(max, Math.min(height[l], height[r]) * (r - l));
        if (height[l] < height[r]) l++;
        else r--;
    }
    return max;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Find the factorial of a large number</span>
                        <span class="badge">Array-based Multiplication</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N log N!)

function factorial(n) {
    let res = [1];
    for (let x = 2; x <= n; x++) {
        let carry = 0;
        for (let i = 0; i < res.length; i++) {
            let prod = res[i] * x + carry;
            res[i] = prod % 10;
            carry = Math.floor(prod / 10);
        }
        while (carry) {
            res.push(carry % 10);
            carry = Math.floor(carry / 10);
        }
    }
    return res.reverse().join('');
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Trapping Rain Water</span>
                        <span class="badge">Two Pointers</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)

function trap(height) {
    let l = 0, r = height.length - 1;
    let leftMax = 0, rightMax = 0;
    let res = 0;
    while (l < r) {
        if (height[l] < height[r]) {
            if (height[l] >= leftMax) leftMax = height[l];
            else res += leftMax - height[l];
            l++;
        } else {
            if (height[r] >= rightMax) rightMax = height[r];
            else res += rightMax - height[r];
            r--;
        }
    }
    return res;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Chocolate Distribution Problem</span>
                        <span class="badge">Sorting + Sliding Window</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N log N)

function findMinDiff(arr, m) {
    if (m === 0 || arr.length === 0) return 0;
    arr.sort((a, b) => a - b);
    let minDiff = Infinity;
    for (let i = 0; i + m - 1 < arr.length; i++) {
        let diff = arr[i + m - 1] - arr[i];
        if (diff < minDiff) minDiff = diff;
    }
    return minDiff;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Insert Interval</span>
                        <span class="badge">Linear Scan</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)

function insert(intervals, newInterval) {
    const res = [];
    let i = 0;
    while (i < intervals.length && intervals[i][1] < newInterval[0]) res.push(intervals[i++]);
    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
        i++;
    }
    res.push(newInterval);
    while (i < intervals.length) res.push(intervals[i++]);
    return res;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Merge Intevals</span>
                        <span class="badge">Sorting + Linear Scan</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N log N)

function merge(intervals) {
    if (!intervals.length) return [];
    intervals.sort((a, b) => a[0] - b[0]);
    const res = [intervals[0]];
    for (let i = 1; i < intervals.length; i++) {
        const last = res[res.length - 1];
        if (intervals[i][0] <= last[1]) last[1] = Math.max(last[1], intervals[i][1]);
        else res.push(intervals[i]);
    }
    return res;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Non-Overlapping Intervals</span>
                        <span class="badge">Greedy</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N log N)

function eraseOverlapIntervals(intervals) {
    if (!intervals.length) return 0;
    intervals.sort((a, b) => a[1] - b[1]);
    let end = intervals[0][1], count = 0;
    for (let i = 1; i < intervals.length; i++) {
        if (intervals[i][0] < end) count++;
        else end = intervals[i][1];
    }
    return count;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Removing repeating frequency</span>
                        <span class="badge">Greedy + Sorting</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N log N)

function minDeletions(s) {
    const freq = new Array(26).fill(0);
    for (let c of s) freq[c.charCodeAt(0) - 97]++;
    freq.sort((a, b) => b - a);
    let del = 0;
    for (let i = 1; i < 26 && freq[i] > 0; i++) {
        if (freq[i] >= freq[i-1]) {
            let prev = freq[i];
            freq[i] = Math.max(0, freq[i-1] - 1);
            del += prev - freq[i];
        }
    }
    return del;
}</code></pre>
                    </div>
                </details>
            </li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>finding out Non zero</span>
                        <span class="badge">Two Pointers</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)

function moveZeroes(nums) {
    let pos = 0;
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== 0) {
            [nums[pos], nums[i]] = [nums[i], nums[pos]];
            pos++;
        }
    }
    return nums;
}</code></pre>
                    </div>
                </details>
            </li>
        </ul>

        <h2>Matrix</h2>
        <ul>
            <li><details><summary class="question-header"><span>Set Matrix Zeroes</span><span class="badge">In-place</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(M*N)

function setZeroes(matrix) {
    let col0 = 1, rows = matrix.length, cols = matrix[0].length;
    for (let i = 0; i < rows; i++) {
        if (matrix[i][0] === 0) col0 = 0;
        for (let j = 1; j < cols; j++)
            if (matrix[i][j] === 0) matrix[i][0] = matrix[0][j] = 0;
    }
    for (let i = rows - 1; i >= 0; i--) {
        for (let j = cols - 1; j >= 1; j--)
            if (matrix[i][0] === 0 || matrix[0][j] === 0) matrix[i][j] = 0;
        if (col0 === 0) matrix[i][0] = 0;
    }
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>Spiral Matrix</span><span class="badge">Simulation</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(M*N)

function spiralOrder(matrix) {
    const res = [];
    let top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1;
    while (top <= bottom && left <= right) {
        for (let i = left; i <= right; i++) res.push(matrix[top][i]);
        top++;
        for (let i = top; i <= bottom; i++) res.push(matrix[i][right]);
        right--;
        if (top <= bottom) {
            for (let i = right; i >= left; i--) res.push(matrix[bottom][i]);
            bottom--;
        }
        if (left <= right) {
            for (let i = bottom; i >= top; i--) res.push(matrix[i][left]);
            left++;
        }
    }
    return res;
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>Program to find the transpose of a matrix</span><span class="badge">In-place Swap</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(M*N)

function transpose(matrix) {
    const rows = matrix.length, cols = matrix[0].length;
    const res = Array.from({ length: cols }, () => Array(rows));
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            res[c][r] = matrix[r][c];
        }
    }
    return res;
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>Word Search</span><span class="badge">Backtracking</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N*M*4^L)

function exist(board, word) {
    const rows = board.length, cols = board[0].length;
    function dfs(r, c, i) {
        if (i === word.length) return true;
        if (r < 0 || c < 0 || r >= rows || c >= cols || board[r][c] !== word[i]) return false;
        const temp = board[r][c];
        board[r][c] = '#';
        const res = dfs(r+1, c, i+1) || dfs(r-1, c, i+1) || dfs(r, c+1, i+1) || dfs(r, c-1, i+1);
        board[r][c] = temp;
        return res;
    }
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (dfs(r, c, 0)) return true;
        }
    }
    return false;
}</code></pre>
            </div></details></li>
        </ul>

        <h2>String</h2>
        <ul>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Longest Substring without Repeating characters</span>
                        <span class="badge">Sliding Window</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)

function lengthOfLongestSubstring(s) {
    let map = new Map();
    let left = 0;
    let maxLen = 0;
    
    for (let right = 0; right < s.length; right++) {
        if (map.has(s[right])) {
            left = Math.max(left, map.get(s[right]) + 1);
        }
        map.set(s[right], right);
        maxLen = Math.max(maxLen, right - left + 1);
    }
    return maxLen;
}</code></pre>
                    </div>
                </details>
            </li>
            <li><details><summary class="question-header"><span>Longest Repeating character replacement</span><span class="badge">Sliding Window</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N)

function characterReplacement(s, k) {
    const count = {};
    let maxCount = 0, left = 0, res = 0;
    for (let right = 0; right < s.length; right++) {
        count[s[right]] = (count[s[right]] || 0) + 1;
        maxCount = Math.max(maxCount, count[s[right]]);
        if ((right - left + 1) - maxCount > k) {
            count[s[left]]--;
            left++;
        }
        res = Math.max(res, right - left + 1);
    }
    return res;
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>Smallest window in a string containing all characters of other string</span><span class="badge">Sliding Window + Frequency Map</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N)

function minWindow(s, t) {
    const map = {};
    for (let c of t) map[c] = (map[c] || 0) + 1;
    let left = 0, right = 0, count = t.length, minLen = Infinity, start = 0;
    while (right < s.length) {
        if (map[s[right++]]-- > 0) count--;
        while (count === 0) {
            if (right - left < minLen) { minLen = right - left; start = left; }
            if (map[s[left++]]++ === 0) count++;
        }
    }
    return minLen === Infinity ? "" : s.substring(start, start + minLen);
}</code></pre>
            </div></details></li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Check whether two string are anagram of each other</span>
                        <span class="badge">Hashing</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)

function isAnagram(s, t) {
    if (s.length !== t.length) return false;
    const map = {};
    for (let c of s) map[c] = (map[c] || 0) + 1;
    for (let c of t) {
        if (!map[c]) return false;
        map[c]--;
    }
    return true;
}</code></pre>
                    </div>
                </details>
            </li>
            <li><details><summary class="question-header"><span>Print all anagram together</span><span class="badge">HashMap</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N * K log K)

function groupAnagrams(strs) {
    const map = {};
    for (let s of strs) {
        const key = s.split('').sort().join('');
        if (!map[key]) map[key] = [];
        map[key].push(s);
    }
    return Object.values(map);
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>Check if given parentheses expression is balanced or not</span><span class="badge">Stack</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N)

function isValid(s) {
    const stack = [], map = { '(': ')', '{': '}', '[': ']' };
    for (let c of s) {
        if (map[c]) stack.push(map[c]);
        else if (stack.pop() !== c) return false;
    }
    return stack.length === 0;
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>Sentence palindrome</span><span class="badge">Two Pointers</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N)

function isPalindrome(s) {
    s = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
    let l = 0, r = s.length - 1;
    while (l < r) {
        if (s[l] !== s[r]) return false;
        l++; r--;
    }
    return true;
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>Longest palindrome Substring</span><span class="badge">Expand Around Center</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N^2)

function longestPalindrome(s) {
    let res = "";
    for (let i = 0; i < s.length; i++) {
        let s1 = expand(s, i, i), s2 = expand(s, i, i+1);
        if (s1.length > res.length) res = s1;
        if (s2.length > res.length) res = s2;
    }
    return res;
    function expand(s, l, r) {
        while (l >= 0 && r < s.length && s[l] === s[r]) { l--; r++; }
        return s.substring(l+1, r);
    }
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>Palindromic Substring</span><span class="badge">Expand Around Center</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N^2)

function countSubstrings(s) {
    let count = 0;
    for (let i = 0; i < s.length; i++) {
        count += expand(s, i, i);
        count += expand(s, i, i+1);
    }
    return count;
    function expand(s, l, r) {
        let c = 0;
        while (l >= 0 && r < s.length && s[l] === s[r]) { c++; l--; r++; }
        return c;
    }
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>Longest common prefix</span><span class="badge">Horizontal Scanning</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(S) where S is sum of all chars

function longestCommonPrefix(strs) {
    if (!strs.length) return "";
    let prefix = strs[0];
    for (let i = 1; i < strs.length; i++) {
        while (strs[i].indexOf(prefix) !== 0) {
            prefix = prefix.substring(0, prefix.length - 1);
            if (!prefix) return "";
        }
    }
    return prefix;
}</code></pre>
            </div></details></li>
        </ul>

        <h2>Linked List</h2>
        <ul>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Reverse a linked list</span>
                        <span class="badge">Iterative</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)

function reverseList(head) {
    let prev = null;
    let curr = head;
    while (curr !== null) {
        let nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}</code></pre>
                    </div>
                </details>
            </li>
            <li><details><summary class="question-header"><span>Merge Two sorted List</span><span class="badge">Iterative</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N + M)

function mergeTwoLists(l1, l2) {
    const dummy = new ListNode(0);
    let curr = dummy;
    while (l1 && l2) {
        if (l1.val < l2.val) { curr.next = l1; l1 = l1.next; }
        else { curr.next = l2; l2 = l2.next; }
        curr = curr.next;
    }
    curr.next = l1 || l2;
    return dummy.next;
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>Merge K sorted Lists</span><span class="badge">Min-Heap</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N log K)

function mergeKLists(lists) {
    if (!lists.length) return null;
    while (lists.length > 1) {
        let a = lists.shift();
        let b = lists.shift();
        lists.push(mergeTwoLists(a, b));
    }
    return lists[0];
}</code></pre>
            </div></details></li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Detect Cycle in a linked list</span>
                        <span class="badge">Fast & Slow Pointers</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)

function hasCycle(head) {
    let slow = head;
    let fast = head;
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow === fast) return true;
    }
    return false;
}</code></pre>
                    </div>
                </details>
            </li>
            <li><details><summary class="question-header"><span>Remove Nth Node from end of list</span><span class="badge">Two Pointers</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N)

function removeNthFromEnd(head, n) {
    const dummy = new ListNode(0, head);
    let slow = dummy, fast = dummy;
    for (let i = 0; i <= n; i++) fast = fast.next;
    while (fast) {
        slow = slow.next;
        fast = fast.next;
    }
    slow.next = slow.next.next;
    return dummy.next;
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>Reorder List</span><span class="badge">Find Mid + Reverse + Merge</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N)

function reorderList(head) {
    if (!head || !head.next) return;
    let slow = head, fast = head;
    while (fast && fast.next) { slow = slow.next; fast = fast.next.next; }
    let prev = null, curr = slow.next;
    slow.next = null;
    while (curr) {
        let temp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = temp;
    }
    let first = head, second = prev;
    while (second) {
        let t1 = first.next, t2 = second.next;
        first.next = second;
        second.next = t1;
        first = t1;
        second = t2;
    }
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>Add 1 to a number represented as linked list</span><span class="badge">Reverse + Add + Reverse</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N)

function addOne(head) {
    head = reverseList(head);
    let curr = head, carry = 1;
    while (curr) {
        let sum = curr.val + carry;
        curr.val = sum % 10;
        carry = Math.floor(sum / 10);
        if (carry === 0) break;
        if (!curr.next && carry) { curr.next = new ListNode(carry); carry = 0; }
        curr = curr.next;
    }
    return reverseList(head);
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>find the middle of a given linked list</span><span class="badge">Fast & Slow Pointers</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N)

function middleNode(head) {
    let slow = head, fast = head;
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>delete last occurrence of an item from linked list</span><span class="badge">Traversal</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N)

function deleteLast(head, key) {
    let x = null, temp = head;
    while (temp) {
        if (temp.val === key) x = temp;
        temp = temp.next;
    }
    if (!x) return head;
    if (x === head) return head.next;
    temp = head;
    while (temp.next !== x) temp = temp.next;
    temp.next = x.next;
    return head;
}</code></pre>
            </div></details></li>
            <li><details><summary class="question-header"><span>Intersection of two linked lists</span><span class="badge">Two Pointers</span></summary><div class="solution-content">
<pre><code>// Time Complexity: O(N + M)

function getIntersectionNode(headA, headB) {
    let a = headA, b = headB;
    while (a !== b) {
        a = a ? a.next : headB;
        b = b ? b.next : headA;
    }
    return a;
}</code></pre>
            </div></details></li>
        </ul>

        <h2>Stack & Queue</h2>
        <ul>
            <li><details><summary class="question-header"><span>Convert infix expression to postfix expression</span><span class="badge">Stack</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>next greater element</span><span class="badge">Monotonic Stack</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Delete middle element of a Stack</span><span class="badge">Recursion</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Check mirror in N-array tree</span><span class="badge">Recursion</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>the celebrity problem</span><span class="badge">Two Pointers / Stack</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>length of the longest valid substring</span><span class="badge">Stack / Counters</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>print right view of a binary tree</span><span class="badge">BFS / DFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>find the first circular tour that visit all petrol pumps</span><span class="badge">Greedy</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>find the maximum of minimum for every window size</span><span class="badge">Monotonic Stack</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>

        <h2>Tree</h2>
        <ul>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Maximum Depth of Binary Tree</span>
                        <span class="badge">DFS</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)

function maxDepth(root) {
    if (!root) return 0;
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}</code></pre>
                    </div>
                </details>
            </li>
            <li><details><summary class="question-header"><span>Diameter of Binary Tree</span><span class="badge">DFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Lowest Common Ancestor of a Binary Search Tree</span><span class="badge">Iterative</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Check if two trees have same structure</span><span class="badge">Recursion</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
             <li>
                <details>
                    <summary class="question-header">
                        <span>Invert Binary Tree</span>
                        <span class="badge">DFS</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)

function invertTree(root) {
    if (!root) return null;
    let temp = root.left;
    root.left = root.right;
    root.right = temp;
    invertTree(root.left);
    invertTree(root.right);
    return root;
}</code></pre>
                    </div>
                </details>
            </li>
            <li><details><summary class="question-header"><span>Binary Tree Maximum Path Sum</span><span class="badge">DFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Binary Tree Zigzag Level Order Traversal</span><span class="badge">BFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Binary Tree Level Order Traversal</span><span class="badge">BFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Serialize and Deserialize Binary Tree</span><span class="badge">Preorder</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Binary Tree Right Side View</span><span class="badge">BFS / DFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Subtree of another tree</span><span class="badge">Preorder Matching</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Binary Tree Paths</span><span class="badge">DFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Construct Binary Tree from Preorder and Inorder Traversal</span><span class="badge">Recursion + Map</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Construct Binary Tree from Inorder and Postorder Traversal</span><span class="badge">Recursion + Map</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Validate Binary Search Tree</span><span class="badge">Recursion</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Kth Smallest Element in a BST</span><span class="badge">Inorder Traversal</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Kth Largest Element in a BST</span><span class="badge">Reverse Inorder</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Construct BST from preorder traversal</span><span class="badge">Recursion</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Lowest Common Ancestor of a Binary Tree</span><span class="badge">Recursion</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Implement Trie (prefix Tree)</span><span class="badge">Array/Map Nodes</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Add and Search word</span><span class="badge">Trie DFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Symmetric Tree</span><span class="badge">Recursion</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>

        <h2>Heap</h2>
        <ul>
            <li><details><summary class="question-header"><span>Top K Frequent Elements</span><span class="badge">Min-Heap</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>K Closest Points to Origin</span><span class="badge">Max-Heap</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Kth Largest Element in an Array</span><span class="badge">QuickSelect</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Merge K Sorted Lists</span><span class="badge">Min-Heap</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>fIND MEDIAN IN A STREAM</span><span class="badge">Two Heaps</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Largest triplet product in a stream</span><span class="badge">Min-Heap</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Connect n ropes with minimum cost</span><span class="badge">Min-Heap</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>

        <h2>Dynamic Programming</h2>
        <ul>
            <li><details><summary class="question-header"><span>Count ways to reach the n'th stair</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Coin Change</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>0/1 Knapsack Problem</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Longest Increasing Subsequence</span><span class="badge">Binary Search</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Edit Distance</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Longest Common Subsequence</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Longest Palindromic Subsequence</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Subset Sum Problem</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Word Break Problem</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Dice Throw Problem</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Maximum sum increasing subsequence</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Longest Bitonic subsequence</span><span class="badge">LIS Left + Right</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Matrix Chain Multiplication</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Longest Common Substring</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Combination Sum</span><span class="badge">Backtracking</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Find maximum possible stolen value from house</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Count possible decoding of a given Digit sequence</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Unique paths in a grid with obstacles</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>jumps over the obstacles</span><span class="badge">Greedy</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Maximum sum of non-adjacent elements</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Maximum sum of subarrays</span><span class="badge">Kadane's</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Cutting a Rod</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Maximum Product Cutting</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Count number of ways to cover a distance</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li>
                <details>
                    <summary class="question-header">
                        <span>Climbing Stairs</span>
                        <span class="badge">DP</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Time Complexity: O(N)

function climbStairs(n) {
    if (n <= 2) return n;
    let a = 1, b = 2;
    for (let i = 3; i <= n; i++) {
        let temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}</code></pre>
                    </div>
                </details>
            </li>
            <li><details><summary class="question-header"><span>Fibonacci Number</span><span class="badge">Iterative</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>

        <h2>Graph</h2>
        <ul>
             <li>
                <details>
                    <summary class="question-header">
                        <span>Number of Islands</span>
                        <span class="badge">DFS</span>
                    </summary>
                    <div class="solution-content">
<pre><code>// Solution placeholder
// Iterate through grid. If '1' found, increment count and trigger DFS/BFS to sink connected land.</code></pre>
                    </div>
                </details>
            </li>
            <li><details><summary class="question-header"><span>Clone Graph</span><span class="badge">DFS + Map</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Course Schedule</span><span class="badge">Topological Sort</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Course Schedule II</span><span class="badge">Topological Sort</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Pacific Atlantic Water Flow</span><span class="badge">DFS/BFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Number of Provinces</span><span class="badge">DFS/BFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Graph Valid Tree</span><span class="badge">Union-Find</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Longest Increasing Path in a Matrix</span><span class="badge">DFS + Memoization</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Word Ladder</span><span class="badge">BFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Word Ladder II</span><span class="badge">BFS + DFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Longest consecutive sequence</span><span class="badge">HashSet</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Snake and Ladder Problem</span><span class="badge">BFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Detect Cycle in a Directed Graph</span><span class="badge">DFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Bridge in a Graph</span><span class="badge">Tarjan's Algo</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Check Whether a Graph is Bipartite</span><span class="badge">BFS/DFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Shortest Path in Weighted Unweighted Graph</span><span class="badge">BFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Find Size of the largest region in Boolean Matrix</span><span class="badge">DFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Topological Sort</span><span class="badge">Kahn's Algo</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Find the number of connected components in an undirected graph</span><span class="badge">DFS/BFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Flood Fill Algorithim</span><span class="badge">BFS/DFS</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Network Delay Time</span><span class="badge">Dijkstra's</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>

        <h3>Union-Find (DSU)</h3>
        <ul>
            <li><details><summary class="question-header"><span>Number of Provinces</span><span class="badge">Union-Find</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Number of Connected Components in an Undirected Graph</span><span class="badge">Union-Find</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Graph Valid Tree</span><span class="badge">Union-Find</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Redundant Connection</span><span class="badge">Union-Find</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>

        <h3>Topological Sort</h3>
        <ul>
            <li><details><summary class="question-header"><span>Course Schedule</span><span class="badge">Kahn's Algo</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Course Schedule II</span><span class="badge">Kahn's Algo</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Alien Dictionary</span><span class="badge">Topological Sort</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>

        <h2>Bit Manipulation</h2>
        <ul>
            <li><details><summary class="question-header"><span>Number of 1 Bits</span><span class="badge">n & (n-1)</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Counting Bits</span><span class="badge">DP</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Missing Number</span><span class="badge">XOR</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Reverse Bits</span><span class="badge">Bitwise Shift</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Find XOR of all subsets of a set</span><span class="badge">Math</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Single Number</span><span class="badge">XOR</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Single Number II</span><span class="badge">Bitwise Counters</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Power of Two</span><span class="badge">n & (n-1)</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>

        <h2>Misc</h2>
        <h3>Cyclic Sort</h3>
        <ul>
            <li><details><summary class="question-header"><span>missing number</span><span class="badge">Cyclic Sort</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>find the missing numbers</span><span class="badge">Cyclic Sort</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>set mismatch</span><span class="badge">Cyclic Sort</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>first missing positive</span><span class="badge">Cyclic Sort</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>
        <h3>Sliding Window</h3>
        <ul>
            <li><details><summary class="question-header"><span>Maximum Sum subarray of size K</span><span class="badge">Sliding Window</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Repeated DNA sequence</span><span class="badge">Sliding Window + Hash</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Mininimum Size Subarray Sum</span><span class="badge">Sliding Window</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Subarray Porduct less than K</span><span class="badge">Sliding Window</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Max consecutive Ones</span><span class="badge">Sliding Window</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>
        <h3>Fast and Slow pointer</h3>
        <ul>
            <li><details><summary class="question-header"><span>Linked List Cycle II</span><span class="badge">Fast & Slow Pointers</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Remove Nth node from the End of list</span><span class="badge">Fast & Slow Pointers</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Find the duplicate number</span><span class="badge">Fast & Slow Pointers</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>palindrome linked list</span><span class="badge">Fast & Slow Pointers</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>
        <h3>Modified Binary search</h3>
        <ul>
            <li><details><summary class="question-header"><span>Search in roated soted array</span><span class="badge">Modified Binary Search</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Find minimum in rotated sorted array</span><span class="badge">Modified Binary Search</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>find peak element</span><span class="badge">Binary Search</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>single element in a sorted array</span><span class="badge">Binary Search</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>minimum time to arrive on time</span><span class="badge">Binary Search on Answer</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>capacity to ship packages within d Days</span><span class="badge">Binary Search on Answer</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>koko eating bananas</span><span class="badge">Binary Search on Answer</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>
        <h3>Kadane's Algorithm</h3>
        <ul>
            <li><details><summary class="question-header"><span>Maximum subarray</span><span class="badge">Kadane's Algorithm</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Maximum product subarray</span><span class="badge">Modified Kadane's</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>
        <h3>Two Pointers Technique</h3>
        <ul>
            <li><details><summary class="question-header"><span>Check if pair with the given Sum exits in an array</span><span class="badge">Two Pointers</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>3 Sum</span><span class="badge">Two Pointers</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Container with most Water</span><span class="badge">Two Pointers</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Trapping Rain Water</span><span class="badge">Two Pointers</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Sort Colors</span><span class="badge">Two Pointers</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Remove Duplicates from Sorted Array</span><span class="badge">Two Pointers</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>
        <h3>Greedy Algorithms</h3>
        <ul>
            <li><details><summary class="question-header"><span>Chocolate Distribution Problem</span><span class="badge">Sorting + Sliding Window</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Merge Intervals</span><span class="badge">Sorting + Linear Scan</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Non-Overlapping Intervals</span><span class="badge">Greedy</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Activity Selection Problem</span><span class="badge">Greedy</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Fractional Knapsack</span><span class="badge">Greedy</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>
        <h3>Backtracking</h3>
        <ul>
            <li><details><summary class="question-header"><span>Word Search</span><span class="badge">Backtracking</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Combination Sum</span><span class="badge">Backtracking</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Subsets</span><span class="badge">Backtracking</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Permutations</span><span class="badge">Backtracking</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>N-Queens Problem</span><span class="badge">Backtracking</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Sudoku Solver</span><span class="badge">Backtracking</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>
        <h3>Monotonic Stack / Queue</h3>
        <ul>
            <li><details><summary class="question-header"><span>Next Greater Element</span><span class="badge">Monotonic Stack</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Largest Rectangle in Histogram</span><span class="badge">Monotonic Stack</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
            <li><details><summary class="question-header"><span>Sliding Window Maximum</span><span class="badge">Monotonic Queue</span></summary><div class="solution-content"><pre><code>// Solution placeholder</code></pre></div></details></li>
        </ul>
    </div>
</body>
</html>